# SEEDLabs -- Shellcode Development Lab

## Overview
Shellcode is widely used in many attacks that involve code injection. Although we can easily find existing shellcode on the Internet, there are situations where we require a shellcode which has to satisfy certain conditions.

There are several challenges in writing shellcode, one is to ensure that there are no zeroes in the binary, and the other is to find the addresses of data used in the command. 
* The first challenge is not very difficult to overcome, and there are several techniques that can be employed. 
* Solutions to the second challenge led to two typical approaches to writing shellcode. 
  * In one approach, data is pushed into the stack during the execution, so that their addresses can be obtained from the stack pointer. 
  * In the second approach, the address of the data is stored in the code region, right after a `call` instruction. When the `call` instruction is executed, the address of the data is treated as the return address, and is pushed into the stack. 

In this lab, we aim to understand the techniques employed in writing shellcode by writing our own shellcode. The following topics are covered here:

1. Shellcode
2. Assembly code
3. Disassembly

## Task 1. Writing Shellcode

Here, we first begin with an example shellcode. Subsequently, the shellcode will be modified to accomplish various tasks. 

Shellcode is typically written using assembly languages, which depend on the computer architecture. In this lab, we will be using the 32-bit Intel architecture (for `x86` processors). In the final task, we will look at the 64-bit Intel architecture.

### 1a: An overview of the process

A basic example of a shellcode `mysh.s` is provided for the lab:

```assembly
; mysh.s

section .text
  global _start
    _start:
      ; Store the argument string on stack
      xor  eax, eax 
      push eax          ; Use 0 to terminate the string
      push "//sh"
      push "/bin"
      mov  ebx, esp     ; Get the string address

      ; Construct the argument array argv[]
      push eax          ; argv[1] = 0
      push ebx          ; argv[0] points "/bin//sh"
      mov  ecx, esp     ; Get the address of argv[]
   
      ; For environment variable 
      xor  edx, edx     ; No env variables 

      ; Invoke execve()
      xor  eax, eax     ; eax = 0x00000000
      mov   al, 0x0b    ; eax = 0x0000000b
      int 0x80
```

We can compile this assembly code using `nasm` -- an assembler and disassembler for the Intel `x86` and `x64` architectures. The option `-f elf32` indicates that we want to assemble the code to 32-bit ELF *object code*. The full command is:

```sh
~$ nasm -f elf32 mysh.s -o mysh.o
```

> **Object code** is a sequence of statements or instructions in a computer language (typically binary machine code). It is the machine code for one particule library or module that will make up the completed product. 

This produces the *object code* `mysh.o`. To generate the executable binary, we use the *linker* `ld`. The option `-m elf_i386` indicates that we want to generate the 32-bit ELF binary. The full command is: 

```sh
~$ ld -m elf_i386 mysh.o -o mysh
```

> The **linker** takes one or more object files (generated by a compiler or an assembler; may be from a library) and combines them into a single executable file.

This gives us the final executable `mysh`. Running the executable gives us a shell. We can verify that a new shell process has spawned by checking the current shell's process ID using `echo $$`. 

![mysh](./img/mysh_spawn_new.png "mysh")

In the image, `7822` is the process ID of original shell, and `7853` is the process ID of the shell spawned by `mysh`.

For the attack, we only need the machine code of the shell code, and not a standalone executable file (which contains data other than the actual machine code). Technically, only the machine code is called *shellcode*. Thus, we need to extract the machine code from the executable file or the object file. There are various ways to do this.

1. We can use `objdump` to disassemble the executable or object file.
   
   ![mysh objdump](./img/mysh_objdump.png "mysh objdump")

   In the image, the hexadecimal numbers in the red box form the machine code. 

   > Note that there are two common syntax modes for assembly code: the AT&T syntax, and the Intel syntax. By default, `objdump` uses the AT&T syntax. Here, we use the option `-Mintel` to specify that we want the Intel syntax

2. Alternatively, we can use `xxd` to print out the contents of the object file, and we should be able to find the machine code.

     ![mysh xxd](./img/mysh_xxd.png "mysh xxd")

     In the image, the hexadecimal numbers in the red box form the machine code.

Finally, in actual attacks, the shellcode need to be included in the attacking code (payload), such as a Python or C program. To convert the machine code into an appropriate array, the Python script `convert.py` is provided: 

```python
# convert.py

#!/usr/bin/env python3

# Run "xxd -p -c 20 rev_sh.o",
# copy and paste the machine code to the following:
ori_sh ="""
copy and paste machine code here
"""

sh = ori_sh.replace("\n", "")

length  = int(len(sh)/2)
print("Length of the shellcode: {}".format(length))
s = 'shellcode= (\n' + '   "'
for i in range(length):
    s += "\\x" + sh[2*i] + sh[2*i+1]
    if i > 0 and i % 16 == 15: 
       s += '"\n' + '   "'
s += '"\n' + ").encode('latin-1')"
print(s)
```

Replacing the variable `ori_sh` in the Python script with the machine code for `mysh.o`, we get the following output:

![mysh_convert](./img/mysh_convert.png "mysh convert")

### 1b: Eliminating zeros from the shellcode

Shellcode is widely used in buffer-overflow attacks. In many cases, the vulnerabilities are caused by string copy, such as the `strcpy()` function. For these string copy functions, the zero byte `\x00` is considered as the end of the string. Therefore, if we have a zero in the middle of the shellcode, string copy will only copy the shellcode up to the zero, to the target buffer, and the attack will fail. 

Although not all vulnerabilities have issues with zero bytes, it is a requirement for shellcode not to have any zeros in the machine code. Otherwise, the application of the shellcode will be limited. 

There are various techniques that can get rid of zeros in the shell code:

* If we want to assign zero to a register, say `eax`, we would naively use the instruction `mov eax, 0`. However, this results in a zero in the machine code. 
  
  To solve this problem, the typical method is to use the **equivalent instruction** `xor eax, eax`. To see how this works, let us look at the truth table of XOR: 

  |  A  |  B  | A XOR B |
  |:---:|:---:|:-------:|
  |  0  |  0  |    0    |
  |  0  |  1  |    1    |
  |  1  |  0  |    1    |
  |  1  |  1  |    0    |

  From this, we can see that whenever the two operands match, the outcome of the XOR operation is `0`. Thus, the result of the instruction `xor eax, eax` is `0x00000000` which is stored back into `eax`. 

  We can explicitly see the difference in the machine code using the following example `xor.s`:

  ```assembly
  ; xor.s

  section .text
  global _start
    _start:
      ; Comparing between mov and xor for setting register to zero
      mov  eax, 0    ; using mov to set to zero
      xor  eax, eax  ; using xor to set to zero
  ```
  Compiling it into object code and using `objdump`, we get the following result:

  ![mov vs. xor](./img/mov_vs_xor.png "mov vs. xor")

  Looking at the machine code in red, we see that the `mov` instruction results in four zeros in the machine code, while the `xor` instruction has no zeros. Both instructions result in the register `eax` having the value `0x00000000`.

* If we want to store, say an 8-bit number like `0x99` into a 32-bit register like `eax`, We cannot simply use `mov eax, 0x99`. The compiler will pad the 8-bit number with zeros to become a 32-bit number -- so the operand becomes `0x00000099` which has three zeros. 
  
  To overcome this, we can first set `eax` to zero (using the `xor` trick), and then assign the 8-bit number `0x99` to the `al` register, which refers to the least significant 8-bits of the `eax` register.

  > For the four of the general purpose 32-bit registers in the `x86` architecture -- `eax`, `ebx`, `ecx` and `edx`, we may refer to their subsections. Taking `eax` as an example, we may refer to the lower 16-bits of the register by `ax`. Within `ax`, we can refer to the lower 8-bits by `al` and the upper 8-bits by `ah`.


  >![Register aliasing](./img/register_alias.png "Register aliasing") 
  *Taken from [nayuki.io](https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming)*

  To explicitly see the difference, we look at the machine code for the following code `al.s`

  ```assembly
  ; al.s

  section .text
  global _start
    _start:
      ; Comparing between moving an 8-bit value to eax and al
      mov  eax, 0x99	; moving 0x99 into eax
      mov   al, 0x99	; moving 0x99 into al
  ```
  The object code after compilation is

  ![eax vs. al](./img/eax_vs_al.png "eax vs. al")

  We can see that indeed, the zeros have been removed from the shell code.

* Another method is to make use of bit shifts. Suppose we want to assign the string `"xyz"` into the register `ebx`. Like before, the string is only 24-bits and will be padded with zeros to fit into the 32-bit register. In  

  We can eliminate the zeros here using bit shifts. We instead assign a string like `"xyz#"` to the register `ebx`, i.e. we pad the string manually with some random character. Most Intel CPUs are little endian, where the least significant byte is stored at the lower address, the hexadecimal value `0x237A7978` is stored into `ebx`. 
  
  Then, we shift the register to the **left** by 8-bits, so the most significant 8-bits -- which represent `'#'` -- are pushed out and discarded. We then shift the register **right** and the most significant byte will filled with a zero. The state of the register after each instruction is illustrated below. 

  ```assembly
  mov  ebx, "xyz#" ;    ebx = 0x237A7978
  shl  ebx, 8      ;    ebx = 0x7A797800
  shr  ebx, 8      ;    ebx = 0x007A7978
  ```

  To see this explicitly, we look at the machine code for the example `bitshift.s`.

  ```assembly
  section .text
  global _start
    _start:
      ; Using bitshift to insert values less than 32-bits
      mov  ebx, "xyz" ;  inserting a 24-bit value

      mov  ebx, "xyz#";  inserting the self-padded 24-bit value
      shl  ebx, 8     ;  shift left 8-bits
      shr  ebx, 8     ;  shift right 8-bits
  ```

  `objdump` gives the following output

  ![bitshift](./img/bitshift.png "bitshift")

  and we see that we have eliminated zeros from the shell code. 
